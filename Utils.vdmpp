class Utils
	functions
		private reduceSeqMeasure[@T, @R]: (@R * @T -> @R) * @R * seq of @T +> nat
		reduceSeqMeasure(-, -, list) == 
			len list
		;
		
		public reduceSeq[@T, @R]: (@R * @T -> @R) -> @R -> seq of @T -> @R
			reduceSeq(f)(starter)(list) == 
			if(len list = 0)
				then starter
				else reduceSeq[@T, @R](f)(f(starter, hd list))(tl list)
			measure reduceSeqMeasure
		;
		
		public reduceSet[@T, @R]: (@R * @T -> @R) -> @R -> set of @T -> @R
			reduceSet(f)(starter)(list) == 
			reduceSeq[@T,@R](f)(starter)(VDMUtil`set2seq[@T](list))
		;
		
		private mapFunctionSeqMeasure[@P, @R]: (@P->@R) * seq of @P +> nat
			mapFunctionSeqMeasure(-,list) == 
			len list
		;
		
		public mapFunctionSeq[@P, @R]: (@P->@R) -> seq of @P -> seq of @R
			mapFunctionSeq(f)(list) == 
			if(len list = 0)
				then []
			else [f(hd list)] ^ mapFunctionSeq[@P, @R](f)(tl list)
			
			measure mapFunctionSeqMeasure
		;
		
		public mapFunctionSet[@P, @R]: (@P->@R) -> set of @P -> set of @R
			mapFunctionSet(f)(list) == 
			seq2set[@R](mapFunctionSeq[@P,@R](f)(VDMUtil`set2seq[@P](list)))
		;
		
		private reduceMapAuxMeasure[@L, @R, @S]: (@S * @L * @R -> @S) * @S * map @L to @R * seq of @L +> nat
			reduceMapAuxMeasure(-, -, -,list) ==
			len list
		;
		
		private reduceMapAux[@L, @R, @S]: (@S * @L * @R -> @S) -> @S -> map @L to @R ->seq of @L -> @S
			reduceMapAux(f)(starter)(m)(list) ==
			if(len list = 0)
				then starter
				else reduceMapAux[@L, @R, @S](f)(f(starter, hd list, m(hd list)))(m)(tl list)
			measure reduceMapAuxMeasure
		;
		
		public reduceMap[@L, @R, @S]: (@S * @L * @R -> @S) -> @S -> map @L to @R -> @S
			reduceMap(f)(starter)(m) ==
			reduceMapAux[@L, @R, @S](f)(starter)(m)(VDMUtil`set2seq[@L](dom m))
		;
		
		private mapFunctionMapAuxMeasure[@L, @R, @S]: (@L*@R->@S) * map @L to @R * seq of @L +> nat
			mapFunctionMapAuxMeasure(-, -, list) ==
			len list
		;
		
		private mapFunctionMapAux[@L, @R, @S]: (@L*@R->@S) -> map @L to @R -> seq of @L -> seq of @S
			mapFunctionMapAux(f)(m)(list) ==
			if(len list = 0)
				then []
			else [f(hd list, m(hd list))] ^ mapFunctionMapAux[@L, @R, @S](f)(m)(tl list)
			
			measure mapFunctionMapAuxMeasure
		;

		public mapFunctionMap[@L, @R, @S]: (@L*@R->@S) -> map @L to @R -> seq of @S
			mapFunctionMap(f)(m) ==
			mapFunctionMapAux[@L, @R, @S](f)(m)(VDMUtil`set2seq[@L](dom m))
		;
		
		public filterSet[@T]: (@T->bool) -> set of @T -> set of @T
			filterSet(f)(list) ==
			{e | e in set list & f(e)} 
		;
		
		public map2set[@L, @R](m: map @L to @R) res: set of (@L*@R) ==
			{ mk_(a,b) | a in set dom m, b in set rng m & b = m(a)}
		;
		
		public map2seq[@L, @R](m: map @L to @R) res: seq of (@L*@R) ==
			VDMUtil`set2seq[(@L*@R)](map2set[@L,@R](m))
		;
		
		public seq2set[@T]: seq of @T +> set of @T
			seq2set(x) ==
			{e | e in set elems x}
		;
		
		private sprintfAuxMeasure: seq of char * seq of ? * seq of char -> nat
			sprintfAuxMeasure(format, -, -) ==
			len format
		;
		
		public sprintfAux: seq of char * seq of ? * seq of char -> seq of char
			sprintfAux(format, list, res) ==
			if(len format = 0)
				then res
			else if(hd format = '{' and hd tl format = '}')
						 then sprintfAux(tl tl format, tl list, res ^ VDMUtil`val2seq_of_char[?](hd list))
						 else sprintfAux(tl format, list, res ^ [hd format])
			
			measure sprintfAuxMeasure
		;
		
		public sprintf: seq of char * seq of ? -> seq of char
			sprintf(format, list) ==
			sprintfAux(format, list, "")
		;
		
		public max: real * real -> real
			max(a,b) ==
			if(a >= b)
				then a
				else b
			post RESULT >= a and RESULT >= b and (RESULT = a or RESULT = b)
		;
		
		public dup: nat -> (nat*nat)
			dup(d) ==
				mk_(d,d)
		;

end Utils