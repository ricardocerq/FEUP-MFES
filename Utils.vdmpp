class Utils
	functions
	
		private reduceSeqMeasure[@T, @R]: (@R * @T -> @R) * @R * seq of @T +> nat
			reduceSeqMeasure(-, -, list) == 
				len list
		;
		
		public reduceSeq[@T, @R]: (@R * @T -> @R) -> @R -> seq of @T -> @R
			reduceSeq(f)(starter)(list) == 
				if(len list = 0)
					then starter
					else reduceSeq[@T, @R](f)(f(starter, hd list))(tl list)
					
			measure reduceSeqMeasure
		;
		
		private reduceTwoSeqMeasure[@L, @R, @S]: (@S * @L * @R -> @S) * @S * seq of @L * seq of @R +> nat
			reduceTwoSeqMeasure(-, -, list1, -) == 
				len list1
		;
		
		public reduceTwoSeq[@L, @R, @S]: (@S * @L * @R -> @S) -> @S -> seq of @L -> seq of @R -> @S
			reduceTwoSeq(f)(starter)(list1)(list2) == 
				if(len list1 = 0)
					then starter
					else reduceTwoSeq[@L, @R, @S](f)(f(starter, hd list1, hd list2))(tl list1)(tl list2)
					
				pre len list1 = len list2
				
			measure reduceTwoSeqMeasure
			
		;
		
		private reduceMultiSeqMeasure[@R]: (@R * seq of ? -> @R) * @R * seq of seq of ? +> nat
			reduceMultiSeqMeasure(-, -, listlist) == 
				len hd listlist
		;
		
		public reduceMultiSeq[@R]: (@R * seq of ? -> @R) -> @R -> seq of seq of ? -> @R
			reduceMultiSeq(f)(starter)(listlist) == 
				if(len hd listlist = 0)
					then starter
					else 
						reduceMultiSeq[@R]
							(f)
							(	
								f(starter, 
									mapFunctionSeq[seq of ?, ?]
										(lambda list: seq of ? & hd list)
										(listlist)
								)
							)
							(
								mapFunctionSeq[seq of ?, ?]
										(lambda list: seq of ? & tl list)
										(listlist)
							)
							
			pre forall list, list2 in seq listlist & len list = len list2
			measure reduceMultiSeqMeasure
		;
		
		public reduceSet[@T, @R]: (@R * @T -> @R) -> @R -> set of @T -> @R
			reduceSet(f)(starter)(list) == 
				reduceSeq[@T,@R](f)(starter)(VDMUtil`set2seq[@T](list))
		;
		
		private mapFunctionSeqMeasure[@P, @R]: (@P->@R) * seq of @P +> nat
			mapFunctionSeqMeasure(-,list) == 
				len list
		;
		
		public mapFunctionSeq[@P, @R]: (@P->@R) -> seq of @P -> seq of @R
			mapFunctionSeq(f)(list) == 
				if(len list = 0)
					then []
				else [f(hd list)] ^ mapFunctionSeq[@P, @R](f)(tl list)
			
			measure mapFunctionSeqMeasure
		;
		
		public mapFunctionSet[@P, @R]: (@P->@R) -> set of @P -> set of @R
			mapFunctionSet(f)(list) == 
				seq2set[@R](mapFunctionSeq[@P,@R](f)(VDMUtil`set2seq[@P](list)))
		;
		
		private reduceMapAuxMeasure[@L, @R, @S]: (@S * @L * @R -> @S) * @S * map @L to @R * seq of @L +> nat
			reduceMapAuxMeasure(-, -, -,list) ==
				len list
		;
		
		private reduceMapAux[@L, @R, @S]: (@S * @L * @R -> @S) -> @S -> map @L to @R ->seq of @L -> @S
			reduceMapAux(f)(starter)(m)(list) ==
				if(len list = 0)
					then starter
					else reduceMapAux[@L, @R, @S](f)(f(starter, hd list, m(hd list)))(m)(tl list)
					
			measure reduceMapAuxMeasure
		;
		
		public reduceMap[@L, @R, @S]: (@S * @L * @R -> @S) -> @S -> map @L to @R -> @S
			reduceMap(f)(starter)(m) ==
				reduceMapAux[@L, @R, @S](f)(starter)(m)(VDMUtil`set2seq[@L](dom m))
		;
		
		private mapFunctionMapAuxMeasure[@L, @R, @S]: (@L*@R->@S) * map @L to @R * seq of @L +> nat
			mapFunctionMapAuxMeasure(-, -, list) ==
				len list
		;
		
		private mapFunctionMapAux[@L, @R, @S]: (@L*@R->@S) -> map @L to @R -> seq of @L -> seq of @S
			mapFunctionMapAux(f)(m)(list) ==
				if(len list = 0)
					then []
			else [f(hd list, m(hd list))] ^ mapFunctionMapAux[@L, @R, @S](f)(m)(tl list)
			
			measure mapFunctionMapAuxMeasure
		;

		public mapFunctionMap[@L, @R, @S]: (@L*@R->@S) -> map @L to @R -> seq of @S
			mapFunctionMap(f)(m) ==
				mapFunctionMapAux[@L, @R, @S](f)(m)(VDMUtil`set2seq[@L](dom m))
		;
		
		public filterSet[@T]: (@T->bool) -> set of @T -> set of @T
			filterSet(f)(list) ==
				{e | e in set list & f(e)} 
		;
		
		public seq2set[@T]: seq of @T +> set of @T
			seq2set(x) ==
				{e | e in set elems x}
		;
		
		private sprintfAuxMeasure: seq of char * seq of ? * seq of char -> nat
			sprintfAuxMeasure(format, -, -) ==
				len format
		;
		
		public sprintfAux: seq of char * seq of ? * seq of char -> seq of char
			sprintfAux(format, list, res) ==
				if(len format = 0)
					then res
				else if(hd format = '{' and hd tl format = '}')
							 then sprintfAux(tl tl format, tl list, res ^ VDMUtil`val2seq_of_char[?](hd list))
							 else sprintfAux(tl format, list, res ^ [hd format])
			
			measure sprintfAuxMeasure
		;
		
		public sprintf: seq of char * seq of ? -> seq of char
			sprintf(format, list) ==
				sprintfAux(format, list, "")
		;
		
		public minAndMax: real -> real -> real * real
			minAndMax(a)(b) ==
				if(a >= b)
					then mk_(b,a)
					else mk_(a,b)
					
			post RESULT.#2 >= RESULT.#1 and 
					 {RESULT.#1, RESULT.#2} = {a,b}
		;
		
		public applyToMinAndMax[@T]: (real*real->@T) -> real -> real -> @T
			applyToMinAndMax(f)(a)(b) ==
				let minAndMax = minAndMax(a)(b),
						max = minAndMax.#2,
						min = minAndMax.#1 in (
						
						f(min, max)	
				)
				
				post (a >= b => RESULT = f(b,a)) and
						 (a < b => RESULT = f(a,b))
		;
		public dup: nat -> (nat*nat)
			dup(d) ==
				mk_(d,d)
		;
		
		public removeIndexMeasure[@T]: seq of @T * nat1 +> nat
			removeIndexMeasure(list,-) ==
				len list
		;
		
		public removeIndex[@T]: seq of @T -> nat1 -> seq of @T
			removeIndex(list)(i) ==
				if(i = 1) then
					tl list
					else [hd list] ^ removeIndex[@T](tl list)(i-1)
			
			pre i >= 1 and i <= len list
			post len list - 1 = len RESULT
			measure removeIndexMeasure
		;
		
		public rearrangeMeasure[@T]: Ordering * seq of @T +> nat
			rearrangeMeasure(orders, -) ==
				len orders
		;
		
		public rearrange[@T]: Ordering -> seq of @T -> seq of @T
			rearrange(orders)(list) ==
				if(len list = 0) then
					 []
				else [list(hd orders)] ^ rearrange[@T](tl orders)(removeIndex[@T](list)(hd orders))
			
			pre len orders = len list		
			measure rearrangeMeasure
		;
		
		public indexOf[@T]: seq of @T ->  @T -> nat1
			indexOf(list)(e) ==
				iota n in set inds list & list(n) = e and forall ix in set inds list & list(ix) = e => n <= ix
			
			pre e in set elems list
			post list(RESULT) = e
		;
		
		public removeElem[@T]: seq of @T -> @T -> seq of @T
			removeElem(list)(e) == 
				removeIndex[@T](list)(indexOf[@T](list)(e))
		; 
		
		public createMap[@L, @R]: seq of @L -> seq of @R -> map @L to @R
			createMap(left)(right) == 
				reduceTwoSeq[@L, @R, map @L to @R](lambda m: map @L to @R, l: @L, r: @R & m ++ {l |-> r})({|->})(left)(right)
			
			post len left = len right and
					 forall i in set inds left & RESULT(left(i)) = right(i)
		;
		
		public createMap[@L, @R]: set of @L -> seq of @R -> map @L to @R
			createMap(left)(right) == 
				createMap[@L,@R](VDMUtil`set2seq[@L](left))(right)
		;
		
		public isOrdering: seq of nat -> bool
			isOrdering(orders) == 
				forall i in set inds orders & orders(i) <= len orders - i + 1
		; 
		
		
		public diff[@T]: seq of @T -> seq of @T -> seq of @T
			diff(list1)(list2) ==
				[el | el in seq list1 & el not in set elems list2]
				
			post forall el in seq list1 & el in set elems list2 <=> el not in set elems RESULT 
		;
		
		public countElems[@T]: seq of @T -> map @T to nat
			countElems(list) ==
				reduceSeq[@T, map @T to nat]
				(lambda acc: map @T to nat, t: @T & if t not in set dom acc then acc ++ {t |-> 1} else acc ++ {t |-> acc(t) +1})
				({|->})
				(list)
				
			post 	dom RESULT = elems list and
						forall val in set dom RESULT & RESULT(val) = len [el | el in seq list & el = val]
		; 
		
		public sameElems[@T]: seq of @T -> seq of @T -> bool
			sameElems(list1)(list2) == 
				countElems[@T](list1) = countElems[@T](list1)
			
			post RESULT <=> (len list1 = len list2 and countElems[@T](list1) = countElems[@T](list1))
		;
		
 		
	operations
		public static randomOrdering: nat ==> Ordering
			randomOrdering(n) == (
				dcl orders: seq of nat := [];
				for x = 0 to n - 1  do (
					orders := orders ^ [MATH`rand(n - x) + 1];
				);
				return orders;
			)
			
			post len RESULT = n
		;
		public static shuffle: seq of ? ==> seq of ?
			shuffle(list) == (
				return rearrange[?](randomOrdering(len list))(list);
			)
		;
		
		public static printf: seq of char * seq of ? ==> ()
			printf(format, list) == (
				IO`print(sprintf(format, list))
			)
		;
		
	types
	
		public Ordering = seq of nat
			inv	list ==
				isOrdering(list)
		;

end Utils