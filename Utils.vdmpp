class Utils
	functions
		private reduceMeasure[@T, @R](f: @R * @T -> @R, list: seq of @T, starter: @R) res: nat ==
			len list
		;
		
		public reduce[@T, @R](f: @R * @T -> @R, list: seq of @T, starter: @R) res: @R ==
			if(len list = 0)
				then starter
				else reduce[@T, @R](f, tl list, f(starter, hd list))
		;
		
		public mapFunction[@P, @R](f: @P->@R, list: seq of @P) res: seq of @R ==
			if(len list = 0)
				then []
			else [f(hd list)] ^ mapFunction[@P, @R](f, tl list)
		;
		
		private reduceMapAux[@L, @R, @S](f: @S * @L * @R -> @S, m: map @L to @R, starter: @S, list: seq of @L) res: @S ==
			if(len list = 0)
				then starter
				else reduceMapAux[@L, @R, @S](f, m, f(starter, hd list, m(hd list)), tl list)
		;
		
		public reduceMap[@L, @R, @S](f: @S * @L * @R -> @S, m: map @L to @R, starter: @S) res: @S ==
			reduceMapAux[@L, @R, @S](f, m, starter, VDMUtil`set2seq[@L](dom m))
		;
		
		private mapFunctionMapAux[@L, @R, @S](f: @L*@R->@S, m: map @L to @R, list: seq of @L) res: seq of @S ==
			if(len list = 0)
				then []
			else [f(hd list, m(hd list))] ^ mapFunctionMapAux[@L, @R, @S](f, m, tl list)
		;

		public mapFunctionMap[@L, @R, @S](f: @L*@R->@S, m: map @L to @R) res: seq of @S ==
			mapFunctionMapAux[@L, @R, @S](f, m, VDMUtil`set2seq[@L](dom m))
		;
		
		public map2set[@L, @R](m: map @L to @R) res: set of (@L*@R) ==
			{ mk_(a,b) | a in set dom m, b in set rng m & b = m(a)}
		;
		
		public map2seq[@L, @R](m: map @L to @R) res: seq of (@L*@R) ==
			VDMUtil`set2seq[(@L*@R)](map2set[@L,@R](m))
		;

end Utils