class Stratego
	instance variables
		public static graphics : gui_Graphics:= new gui_Graphics();
	types
	
		public Point:: 	
			x: nat1
			y: nat1;
												
		public Move:: 	
			src: Point
			dst: Point
			--inv mk_Move(s, d) == aligned(s)(d)
		;				
		public Character = 	 
			<Flag>
		| <Bomb> 		
		| <Spy> 				
		| <Scout>
		| <Miner>
		| <Sergeant> 
		| <Lieutenant> 
		| <Captain>
		| <Major>
		| <Colonel> 
		| <General> 
		| <Marshal>;
											 
		public Team = 
			<Red>
		| <Blu>
		;
		
		public Piece::
			character: Character
			team: Team
		;
								
	values
		
	functions
		public dist: Point -> Point -> real
			dist(src)(dst) == 
				MATH`sqrt((src.x-dst.x)*(src.x-dst.x) + (src.y-dst.y)*(src.y-dst.y))
		;
		public alignment: Point -> Point -> (bool*bool)
			alignment(p1)(p2) ==
				mk_(p1.x = p2.x, p1.y = p2.y)
			
			post RESULT.#1 = true <=> p1.x = p2.x and 
					 RESULT.#2 = true <=> p1.y = p2.y 					 
		;
		
		public aligned: Point->Point->bool
			aligned(src)(dst) ==
				let align = alignment(src)(dst) in (
					not (align.#1 and align.#2) and align.#1 or align.#2
				)
		;
		
		public getOpponent: Team -> Team
			getOpponent(pl) ==
			if pl = <Red> 
				then <Blu> 
				else <Red>
			
			post RESULT <> pl
		;
		
		public inInterval: nat * nat -> nat1 -> bool
			inInterval(a,b)(val) ==
			let maxMin = Utils`maxAndMin(a, b),
					fl = maxMin.#2,
					ceil = maxMin.#1 in (
					val > fl and val < ceil
			)
		;
		
		public validDim: nat1 -> bool 
			validDim(v) ==
			inInterval(0, StrategoRules`boardSize+1)(v)
		;
		
		public intervalSet: nat*nat -> set of nat1
			intervalSet(a,b) ==
			let maxMin = Utils`maxAndMin(a, b),
					fl = maxMin.#2,
					ceil = maxMin.#1 in (
					{fl+1, ..., ceil-1}
			)
			
			pre a >= 0 and b >= 0
			post forall e in set RESULT & inInterval(a, b)(e)
		;
		
		public validDimSet: () -> set of nat1
			validDimSet() ==
			intervalSet(0, StrategoRules`boardSize+1)
		;
		
		public validPoint: Point -> bool 
			validPoint(p) ==
			validDim(p.x) and validDim(p.y)
		;
		
		public invertedPoint: Point -> Point
			invertedPoint(p) == 
			mk_Point(p.x, StrategoRules`boardSize - p.y + 1)
				
			pre validPoint(p)
			post validPoint(p) and p.x = RESULT.x and p.y = StrategoRules`boardSize - RESULT.y + 1
		;
		
		public pointsInRanges: set of nat1 * set of nat1 -> set of Point
			pointsInRanges(xrange, yrange) ==
			{ mk_Point(x,y) | x in set xrange , y in set yrange }
			
			post forall a in set RESULT & validPoint(a)
		;
		
		public allPoints: () -> set of Point
			allPoints() ==
			pointsInRanges(validDimSet(),validDimSet())
		;
		
		public pointsFiltered: (() -> set of Point) -> (Point->bool) -> set of Point
			 pointsFiltered(gen)(f)==
			 Utils`filterSet[Point](f)(gen())
		;
		
		public allPointsFiltered: (Point->bool) -> set of Point
			 allPointsFiltered(f)==
			 pointsFiltered(allPoints)(f)
		;
		
		public isInBackRowBlu: Point -> bool
			isInBackRowBlu(p) ==
			p.y = 1
			
			post RESULT <=> (p.y = 1) -- trivial
		;
		
		public isInBackRowRed: Point -> bool
		isInBackRowRed(p) ==
			p.y = StrategoRules`boardSize
			
			post RESULT <=> (p.y = StrategoRules`boardSize) -- trivial
		;
		
		public isInBackRow: Team -> Point -> bool
			isInBackRow(pl)(p) ==
			if pl = <Red>
				then isInBackRowRed(p)
				else isInBackRowBlu(p)
				
			pre validPoint(p)
			post pl = <Red> => ((RESULT = true) <=> isInBackRowRed(p)) and
					 pl = <Blu> => ((RESULT = true) <=> isInBackRowBlu(p))
		;
		
		public isInTeamAreaBlu: Point -> bool
			isInTeamAreaBlu(p) ==
			p.y > 0 and p.y <= StrategoRules`boardSize * StrategoRules`sideProportion
			
			post RESULT <=> (p.y > 0 and p.y <= StrategoRules`boardSize * StrategoRules`sideProportion) -- trivial
		;
		
		public isInTeamAreaRed: Point -> bool
			isInTeamAreaRed(p) ==
			p.y <= StrategoRules`boardSize and p.y > StrategoRules`boardSize - StrategoRules`boardSize * StrategoRules`sideProportion
			
			post RESULT <=> (p.y <= StrategoRules`boardSize and p.y > StrategoRules`boardSize - StrategoRules`boardSize * StrategoRules`sideProportion) --trivial
		;
		
		public isInTeamArea: Team -> Point -> bool
			isInTeamArea(pl)(p) ==
			if pl = <Red>
				then isInTeamAreaRed(p)
				else isInTeamAreaBlu(p)
				
			pre validPoint(p)
			post pl = <Red> => ((RESULT = true) <=> isInTeamAreaRed(p)) and
					 pl = <Blu> => ((RESULT = true) <=> isInTeamAreaBlu(p))
		;
		public isLake:Point -> bool
			isLake(p) == 
			p in set StrategoRules`lakes
		;
		public pointsBetween: Point -> Point ->  set of Point
			pointsBetween(src)(dst) ==
				let align = alignment(src)(dst)
						in (
						if(align.#1)
							then pointsInRanges({src.x}, intervalSet(src.y, dst.y))
							else pointsInRanges(intervalSet(src.x, dst.x), {src.y})
				)
				pre aligned(src)(dst)
		;
		
		public isValidMove: StrategoState`Instance -> Move -> bool
			isValidMove(inst)(m) ==
			not isLake(m.src) and
			not isLake(m.dst) and 
			aligned(m.src)(m.dst) and 
			let srcPiece = StrategoState`pieceAt(inst.board)(m.src),
					dstPiece = StrategoState`pieceAt(inst.board)(m.dst),
					ruleset = inst.ruleSet,
					piecesInBetween = Utils`mapFunctionSet[Point, [Piece]](StrategoState`pieceAt(inst.board))(pointsBetween(m.src)(m.dst))
					in (
					srcPiece <> nil and
					srcPiece.team = inst.currentTeam and
					(dstPiece = nil or dstPiece.team = getOpponent(srcPiece.team)) and
					dist(m.src)(m.dst) <= StrategoRules`getMovementRange(ruleset)(srcPiece.character) and
					(piecesInBetween = {} or piecesInBetween = {nil})
			)
			pre validPoint(m.src) and validPoint(m.dst)
		;
		
		public executeMove: StrategoState`Instance -> Move -> StrategoState`Instance
			executeMove(inst)(m) == 
			let srcPiece = StrategoState`pieceAt(inst.board)(m.src),
					dstPiece = StrategoState`pieceAt(inst.board)(m.dst),
					attackRes = StrategoRules`resolveAttack(inst.ruleSet)(srcPiece)(dstPiece),
					currPlayerCap = if attackRes.#1 then nil else srcPiece,
					nextPlayerCap = if attackRes.#2 then nil else dstPiece,
					currTeam = inst.currentTeam,
					currPlayer = inst.players(currTeam),
					nextTeam = getOpponent(inst.currentTeam),
					nextPlayer = inst.players(nextTeam) in (
				mk_StrategoState`Instance(
					inst.ruleSet, 
					nextTeam,
					inst.players ++ {
							currTeam |-> StrategoState`addCapture(StrategoState`addMovePlayer(currPlayer)(m))(currPlayerCap),
							nextTeam |-> StrategoState`addCapture(nextPlayer)(nextPlayerCap)
					},
					StrategoState`addMoveBoard(inst.board)(m)(attackRes)
				)
			)
			pre isValidMove(inst)(m)
		; 
		
	operations
		public Run: () ==> ()
		Run() == (
			graphics.init();
			graphics.testFunc2(StrategoState`setBoard(StrategoState`defaultStartingInstance(), StrategoState`fillBoardRandom(StrategoState`defaultStartingInstance().ruleSet)));
	 	)

end Stratego

