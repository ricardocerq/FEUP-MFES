class StrategoState
	types
		public Board  = map Stratego`Point to Stratego`Piece
		;
		
		public Player::
			team: Stratego`Team
			plays: seq of Stratego`Move
			captured: seq of Stratego`Character
		;
		
		public Instance::
			ruleSet: StrategoRules`RuleSet
			currentTeam: Stratego`Team
			players: map Stratego`Team to Player
			board: Board
			
			inv mk_Instance(-,-,pl,-) == forall team in set dom pl & pl(team).team = team
																		and card dom pl = 2
		;
		
	functions
		public defaultStartingInstance: () -> Instance
			defaultStartingInstance() ==
				 mk_StrategoState`Instance(
				 	StrategoRules`getDefaultRuleSet(), 
				 	<Blu>,
				 	{<Blu> |-> newPlayer(<Blu>) , <Red> |-> newPlayer(<Red>)},
				 	{|->}
				 )
		;
		
		public newPlayer: Stratego`Team -> Player
			newPlayer(t) == 
			mk_Player(t, [], [])
		;
		
		public pieceAt: Board -> Stratego`Point -> [Stratego`Piece]
			pieceAt(board)(p) ==
			if p in set dom board
				then board(p)
				else nil
			pre Stratego`validPoint(p)
		;
		
		public addMovePlayer: Player -> Stratego`Move -> Player
			addMovePlayer(p)(move) ==
			mk_Player(p.team, p.plays ^ [move], p.captured)
			
			post RESULT.team = p.team and RESULT.plays = p.plays ^ [move]  and RESULT.captured = p.captured
		;
		
		public addCapture: Player -> [Stratego`Piece] -> Player
			addCapture(p)(piece) ==
			if(piece = nil)
				then p
			else mk_Player(p.team, p.plays, p.captured ^ [piece.character])
			
			post RESULT.team = p.team and RESULT.plays = p.plays and (piece = nil or RESULT.captured = p.captured ^ [piece.character])
		;
		
		public addMoveBoard: Board -> Stratego`Move -> (bool*bool) -> Board 
			addMoveBoard(board)(m)(mk_(keepSrc,keepDst)) ==
			let srcPiece = StrategoState`pieceAt(board)(m.src),
					boardNoSrc = ({m.src} <-: board)
					in (
					if keepDst
						then boardNoSrc -- only remove src
						else if keepSrc
										then boardNoSrc ++ {m.dst |-> srcPiece} -- replace piece at dst with src piece
										else {m.dst} <-: boardNoSrc -- remove both
			)
			pre not (keepSrc and keepDst) and StrategoState`pieceAt(board)(m.src) <> nil
			post StrategoState`pieceAt(board)(m.src) = nil
		;
		public setBoard: Instance * Board -> Instance
			setBoard(inst, board) ==
			mk_Instance(inst.ruleSet, inst.currentTeam, inst.players, board)
		;
		public placePieceBoard: Board -> Stratego`Piece -> Stratego`Point -> Board
			placePieceBoard(board)(piece)(p) ==
				board ++ {p |-> piece}
			pre pieceAt(board)(p) = nil
		;
		
		public placePieceInstance: Instance -> Stratego`Piece -> Stratego`Point -> Instance
			placePieceInstance(inst)(piece)(p) ==
				mk_Instance(inst.ruleSet, inst.currentTeam, inst.players, placePieceBoard(inst.board)(piece)(p))
			pre pre_placePieceBoard(inst.board)(piece)(p)
		;
		
	operations
	
		public static fillBoard: StrategoRules`RuleSet ==> Board
			fillBoard(ruleSet) == (
				let areaGen = lambda t: Stratego`Team & Stratego`allPointsFiltered(Stratego`isInTeamArea(t)),
						bluArea = areaGen(<Blu>),
						redArea = areaGen(<Red>),
						characters = StrategoRules`getAllCharacters(ruleSet),
						teamToPiece = lambda t: Stratego`Team & (lambda c: Stratego`Character & mk_Stratego`Piece(c, t)),
						teamToPieces = lambda t: Stratego`Team & Utils`mapFunctionSeq[Stratego`Character, Stratego`Piece](teamToPiece(t))(characters),
						bluPieces = teamToPieces(<Blu>),
						redPieces = teamToPieces(<Red>)
 						 in (
							return Utils`createMap[Stratego`Point, Stratego`Piece](bluArea)(Utils`shuffle(bluPieces)) ++
											Utils`createMap[Stratego`Point, Stratego`Piece](redArea)(Utils`shuffle(redPieces))
				)
			)
		;
end StrategoState